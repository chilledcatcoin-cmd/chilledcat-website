<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Chilled Cat Solitaire</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --pile-w: 90px; --pile-h: 130px; --stack-gap: 20px; }
    * { box-sizing: border-box; }
    body { margin: 0; background: linear-gradient(to bottom, #133b5c, #1e5f74); font-family: system-ui, sans-serif; color: #fff; }
    h1 { text-align: center; padding: 12px; margin: 0; }
    #statusBar { display: flex; justify-content: center; gap: 40px; font-size: 1.1rem; margin: 8px 0 6px; }
    #board { display: grid; grid-template-rows: 150px auto; gap: 16px; padding: 16px; max-width: 1100px; margin: 0 auto; }
    #top { display: grid; grid-template-columns: repeat(7, var(--pile-w)); grid-auto-rows: var(--pile-h); gap: 14px; justify-content: center; align-items: start; }
    #tableau { display: grid; grid-template-columns: repeat(7, var(--pile-w)); grid-auto-rows: var(--pile-h); gap: 14px; justify-content: center; }
    .pile { width: var(--pile-w); height: var(--pile-h); border: 2px dashed rgba(255,255,255,0.35); border-radius: 6px; position: relative; }
    .pile.highlight { outline: 3px solid rgba(255, 217, 102, 0.9); }
    .card { width: var(--pile-w); height: var(--pile-h); border-radius: 6px; position: absolute; left: 0; top: 0; background-size: cover; background-position: center; cursor: grab; user-select: none; }
    .card:active { cursor: grabbing; }
    .face-down { background-image: url("cards/back.png"); }
    #winPopup { position: fixed; inset: 0; display: flex; align-items: center; justify-content: center; background: rgba(0,0,0,0.8); visibility: hidden; z-index: 100; }
    #winPopup .box { background: #143a52; border: 2px solid #9cf; border-radius: 10px; padding: 20px 28px; text-align: center; }
    #winPopup .box button { margin-top: 14px; font-size: 1rem; padding: 10px 18px; border: none; border-radius: 8px; background: #ffd966; cursor: pointer; }
    #controls { display:flex; justify-content:center; gap:12px; margin-bottom:8px; }
    #controls button { padding: 6px 10px; border-radius: 8px; border: 1px solid #9cf; background:#0c2a41; color:#fff; cursor:pointer; }
    #controls button:hover { background:#0e3552; }
    @media (max-width: 780px){
      :root { --pile-w: 64px; --pile-h: 92px; --stack-gap: 16px; }
      #top, #tableau { gap: 10px; }
    }
  </style>
</head>
<body>
  <h1>Chilled Cat Solitaire üêæ</h1>
  <div id="statusBar">
    <div>‚è± Time: <span id="time">0</span>s</div>
    <div>üèÜ Score: <span id="score">0</span></div>
  </div>
  <div id="controls">
    <button id="newGameBtn">New Game</button>
    <button id="hintBtn">Hint</button>
  </div>
  <div id="board">
    <div id="top">
      <div id="stock" class="pile" title="Stock (click to draw)"></div>
      <div id="waste" class="pile" title="Waste"></div>
      <div class="pile spacer"></div>
      <div id="f-hearts" class="pile" data-type="foundation" data-suit="hearts" title="Foundation ‚ô•"></div>
      <div id="f-diamonds" class="pile" data-type="foundation" data-suit="diamonds" title="Foundation ‚ô¶"></div>
      <div id="f-clubs" class="pile" data-type="foundation" data-suit="clubs" title="Foundation ‚ô£"></div>
      <div id="f-spades" class="pile" data-type="foundation" data-suit="spades" title="Foundation ‚ô†"></div>
    </div>
    <div id="tableau"></div>
  </div>

  <div id="winPopup">
    <div class="box">
      <div style="font-size:1.6rem;margin-bottom:6px;">üéâ You Win! üéâ</div>
      <div>Final Score: <span id="finalScore"></span></div>
      <div>Final Time: <span id="finalTime"></span>s</div>
      <button id="playAgainBtn">Play Again</button>
    </div>
  </div>

<script>
// ---------------- Core Data ----------------
const suits = ["hearts","diamonds","clubs","spades"];
const values = ["A","2","3","4","5","6","7","8","9","10","J","Q","K"];
const colors = { hearts:"red", diamonds:"red", clubs:"black", spades:"black" };

let deck=[], stock=[], waste=[];
let tableau=[[],[],[],[],[],[],[]];
let foundations={ hearts:[], diamonds:[], clubs:[], spades:[] };

let score=0, seconds=0, timerInterval=null;

// --------------- Utils ----------------
function createDeck(){
  deck=[];
  for(const s of suits){ for(const v of values){ deck.push({suit:s, value:v, faceUp:false}); } }
}
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } }
function deal(){
  tableau=[[],[],[],[],[],[],[]];
  waste=[]; foundations={ hearts:[], diamonds:[], clubs:[], spades:[] };
  let idx=0;
  for(let col=0; col<7; col++){
    for(let row=0; row<=col; row++){
      const c=deck[idx++]; c.faceUp = (row===col);
      tableau[col].push(c);
    }
  }
  stock = deck.slice(idx);
}
function valueIndex(v){ return values.indexOf(v); }

// --------------- Rendering ----------------
function render(){
  document.getElementById("score").textContent = score;
  document.getElementById("time").textContent = seconds;

  // Stock
  const stockEl=document.getElementById("stock"); stockEl.innerHTML="";
  if(stock.length>0){
    const c=document.createElement("div");
    c.className="card face-down";
    stockEl.appendChild(c);
    stockEl.onclick=()=>{ const card=stock.pop(); card.faceUp=true; waste.push(card); score+=5; render(); };
  }else{
    stockEl.onclick=()=>{ if(waste.length===0) return; stock=waste.reverse().map(c=>({...c,faceUp:false})); waste=[]; render(); };
  }
  addDropHandlers(stockEl, {type:"stock"}); // allow dropping never, but keeps consistency

  // Waste
  const wasteEl=document.getElementById("waste"); wasteEl.innerHTML="";
  if(waste.length>0){
    const top=waste[waste.length-1];
    const el=createCardElement(top,"waste",waste.length-1);
    wasteEl.appendChild(el);
    addDropHandlers(el.parentElement, {type:"waste"});
  }else{
    addDropHandlers(wasteEl, {type:"waste"});
  }

  // Foundations
  for(const s of suits){
    const pileEl=document.getElementById("f-"+s);
    pileEl.innerHTML="";
    if(foundations[s].length>0){
      const top=foundations[s][foundations[s].length-1];
      const el=createCardElement(top,"foundation",foundations[s].length-1,s);
      pileEl.appendChild(el);
    }
    addDropHandlers(pileEl, {type:"foundation", suit:s});
  }

  // Tableau
  const tabEl=document.getElementById("tableau"); tabEl.innerHTML="";
  tableau.forEach((col, colIndex)=>{
    const pile=document.createElement("div");
    pile.className="pile";
    pile.dataset.type="tableau"; pile.dataset.index=String(colIndex);
    col.forEach((card,rowIndex)=>{
      const el=createCardElement(card,"tableau",rowIndex,colIndex);
      el.style.top = (rowIndex*parseInt(getComputedStyle(document.documentElement).getPropertyValue('--stack-gap'))) + "px";
      el.style.zIndex = String(100+rowIndex);
      pile.appendChild(el);
    });
    addDropHandlers(pile, {type:"tableau", index:colIndex});
    tabEl.appendChild(pile);
  });

  checkWin();
}

function cardImageUrl(card){
  return `cards/${card.value}${card.suit[0].toUpperCase()}.png`;
}

function createCardElement(card, pileType, index, extra){
  const div=document.createElement("div");
  div.className="card";
  if(card.faceUp){
    div.style.backgroundImage = `url("${cardImageUrl(card)}")`;
    div.draggable=true;
    div.addEventListener("dragstart", e=>{
      e.dataTransfer.setData("application/json", JSON.stringify({pileType,index,extra}));
    });
    // double-click (smart move to foundation)
    div.addEventListener("dblclick", ()=>{
      autoToFoundation(pileType, index, extra);
    });
  }else{
    div.classList.add("face-down");
    div.style.backgroundImage = `url("cards/back.png")`;
  }
  return div;
}

// Accept drops on both empty piles and on top cards (use capture to avoid child interception)
function addDropHandlers(el, targetData){
  el.addEventListener("dragover", e=>{ e.preventDefault(); }, true);
  el.addEventListener("drop", e=>{
    e.preventDefault();
    const raw = e.dataTransfer.getData("application/json") || e.dataTransfer.getData("text/plain");
    if(!raw) return;
    const data = JSON.parse(raw);
    handleMove(data, targetData);
  }, true);
}

// --------------- Rules ----------------
function canMoveToFoundation(card, suit){
  if(card.suit!==suit) return false;
  const pile = foundations[suit];
  if(pile.length===0) return card.value==="A";
  return valueIndex(card.value) === valueIndex(pile[pile.length-1].value)+1;
}
function canMoveToTableau(card, colIndex){
  const pile = tableau[colIndex];
  if(pile.length===0) return card.value==="K";
  const top = pile[pile.length-1];
  return colors[card.suit]!==colors[top.suit] && valueIndex(card.value)===valueIndex(top.value)-1;
}

function flipLast(p){
  if(p.length>0 && !p[p.length-1].faceUp){ p[p.length-1].faceUp=true; score+=5; }
}

// Move handler
function handleMove(data, target){
  let moved=false;

  if(data.pileType==="waste"){
    const moving = waste[data.index];
    if(!moving || !moving.faceUp) return;
    if(target.type==="foundation" && canMoveToFoundation(moving, target.suit)){ foundations[target.suit].push(waste.pop()); score+=10; moved=true; }
    else if(target.type==="tableau" && canMoveToTableau(moving, target.index)){ tableau[target.index].push(waste.pop()); score+=5; moved=true; }
  }else if(data.pileType==="tableau"){
    const fromCol = data.extra;
    const moving = tableau[fromCol][data.index];
    if(!moving || !moving.faceUp) return;
    const stack = tableau[fromCol].slice(data.index);
    if(target.type==="foundation"){
      // only single cards to foundation
      if(stack.length===1 && canMoveToFoundation(moving, target.suit)){
        foundations[target.suit].push(stack[0]);
        tableau[fromCol] = tableau[fromCol].slice(0, data.index);
        flipLast(tableau[fromCol]);
        score+=10; moved=true;
      }
    }else if(target.type==="tableau"){
      if(canMoveToTableau(moving, target.index)){
        tableau[target.index] = tableau[target.index].concat(stack);
        tableau[fromCol] = tableau[fromCol].slice(0, data.index);
        flipLast(tableau[fromCol]);
        score+=5; moved=true;
      }
    }
  }

  if(moved) render();
}

// Double-click helper to send a card to its foundation if legal
function autoToFoundation(pileType, index, extra){
  if(pileType==="waste"){
    const c=waste[index];
    if(!c) return;
    const dest=foundations[c.suit];
    if(canMoveToFoundation(c, c.suit)){ dest.push(waste.pop()); score+=10; render(); }
  }else if(pileType==="tableau"){
    const col=extra; const c=tableau[col][index];
    if(!c) return;
    // must be top of its column to auto-move
    if(index !== tableau[col].length-1) return;
    if(canMoveToFoundation(c, c.suit)){
      foundations[c.suit].push(c);
      tableau[col].pop();
      flipLast(tableau[col]);
      score+=10; render();
    }
  }
}

// --------------- Timer & Win ---------------
function startTimer(){ if(timerInterval) clearInterval(timerInterval); seconds=0; timerInterval=setInterval(()=>{ seconds++; document.getElementById("time").textContent = seconds; }, 1000); }
function checkWin(){
  let total=0; for(const s of suits) total+=foundations[s].length;
  if(total===52){
    clearInterval(timerInterval);
    document.getElementById("finalScore").textContent = String(score);
    document.getElementById("finalTime").textContent = String(seconds);
    document.getElementById("winPopup").style.visibility="visible";
  }
}
function startGame(){
  createDeck(); shuffle(deck); deal();
  score=0; seconds=0; startTimer();
  render();
  document.getElementById("winPopup").style.visibility="hidden";
}

// --------------- Controls ---------------
document.getElementById("newGameBtn").addEventListener("click", startGame);
document.getElementById("playAgainBtn").addEventListener("click", startGame);

// Init
startGame();
</script>
</body>
</html>
